import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import io
import base64
from datetime import datetime, timedelta
from typing import List, Dict

def get_available_timeframes() -> Dict[str, str]:
    """Get available timeframe options for vulnerability history"""
    return {
        "7D": "Last 7 Days",
        "30D": "Last 30 Days", 
        "90D": "Last 3 Months (Recommended)",
        "180D": "Last 6 Months",
        "365D": "Last Year",
        "730D": "Last 2 Years"
    }

def get_latest_assets(df: pd.DataFrame) -> pd.DataFrame:
    """Consistent with other intents - gets latest records for each unique asset"""
    df = df.copy()
    df['Plugin Modification Date'] = pd.to_datetime(df['Plugin Modification Date'], errors='coerce')
    df = df.dropna(subset=['Plugin Modification Date'])
    df['vuln_id'] = df['IP Address'] + "|" + df['Port'].astype(str) + "|" + df['Plugin'].astype(str)
    df = df.sort_values('Plugin Modification Date', ascending=False)
    return df.drop_duplicates(subset=['vuln_id'], keep='first')

async def display_vulnerability_history(records: List[Dict], time_window: str = '90D') -> Dict:
    """
    Displays vulnerability discovery history over time with severity trends
    
    Args:
        records: List of vulnerability scan records
        time_window: Time window options:
            - '7D': Last 7 Days
            - '30D': Last 30 Days
            - '90D': Last 3 Months (default/recommended)
            - '180D': Last 6 Months
            - '365D': Last Year
            - '730D': Last 2 Years
    """
    if not records:
        return {"message": "No records found"}

    df = pd.DataFrame(records)
    if df.empty:
        return {"message": "Data is empty"}

    # Process dates and get latest records
    df['Plugin Modification Date'] = pd.to_datetime(df['Plugin Modification Date'], errors='coerce')
    df = df.dropna(subset=['Plugin Modification Date'])
    df['Date'] = df['Plugin Modification Date'].dt.date
    
    # Define time windows and their configurations
    TIME_WINDOWS = {
        '7D': {'days': 7, 'freq': '1D', 'title': 'Last 7 Days', 'format': '%Y-%m-%d'},
        '30D': {'days': 30, 'freq': '1D', 'title': 'Last 30 Days', 'format': '%Y-%m-%d'},
        '90D': {'days': 90, 'freq': '7D', 'title': 'Last 3 Months', 'format': '%Y-%m-%d'},
        '180D': {'days': 180, 'freq': '7D', 'title': 'Last 6 Months', 'format': '%Y-%m-%d'},
        '365D': {'days': 365, 'freq': '30D', 'title': 'Last Year', 'format': '%Y-%m'},
        '730D': {'days': 730, 'freq': '30D', 'title': 'Last 2 Years', 'format': '%Y-%m'}
    }
    
    # Get configuration for the specified time window
    if time_window not in TIME_WINDOWS:
        time_window = '90D'  # Default to 3 months
    
    config = TIME_WINDOWS[time_window]
    current_date = datetime.now()
    cutoff_date = current_date - timedelta(days=config['days'])
    freq = config['freq']
    title_suffix = config['title']
    time_format = config['format']
    
    # Filter dataframe to the specified time window
    df_filtered = df[df['Plugin Modification Date'] >= cutoff_date].copy()
    
    if df_filtered.empty:
        return {"message": f"No data found for the {title_suffix.lower()}"}
    
    # Create timeline visualization
    plt.figure(figsize=(14, 8))
    
    # Set index for resampling
    df_filtered.set_index('Plugin Modification Date', inplace=True)
    
    # Resample by frequency and count vulnerabilities
    resampled = df_filtered.resample(freq).size()
    
    # Plot total vulnerabilities
    plt.plot(resampled.index, resampled.values, 
             marker='o', linestyle='-', color='#1f77b4', 
             label='Total Vulnerabilities', linewidth=2)
    
    # Plot severity trends if available
    if 'Severity' in df_filtered.columns:
        severity_counts = df_filtered.groupby([pd.Grouper(freq=freq), 'Severity']).size().unstack(fill_value=0)
        
        # Ensure all severity levels are present
        for severity in ['Critical', 'High', 'Medium', 'Low']:
            if severity not in severity_counts.columns:
                severity_counts[severity] = 0
        
        # Plot each severity
        colors = {'Critical': '#d62728', 'High': '#ff7f0e', 
                 'Medium': "#b3a103", 'Low': '#2ca02c'}
        for severity in ['Critical', 'High', 'Medium', 'Low']:
            if severity in severity_counts.columns:
                plt.plot(severity_counts.index, severity_counts[severity], 
                         marker='.', linestyle='--', color=colors[severity],
                         label=f'{severity} Vulnerabilities', alpha=0.7)
    
    # Format plot
    plt.title(f'Vulnerability Discovery History ({title_suffix})', pad=20)
    plt.xlabel('Date')
    plt.ylabel('Number of Vulnerabilities')
    plt.grid(True, linestyle='--', alpha=0.5)
    plt.legend()
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    # Save visualization with optimized settings
    buffer = io.BytesIO()
    plt.savefig(buffer, format='png', dpi=72, bbox_inches='tight')
    buffer.seek(0)
    timeline_image = base64.b64encode(buffer.read()).decode('utf-8')
    buffer.close()
    plt.close()
    
    # Add metadata about available time windows
# Prepare response data
    response_data = {
    "time_period": title_suffix,
    "total_vulnerabilities": int(resampled.sum()),
    "peak_vulnerabilities": {
        "count": int(resampled.max()) if len(resampled) > 0 else 0,
        "date": resampled.idxmax().strftime(time_format) if len(resampled) > 0 else "N/A"
    },
    "recent_trend": "increasing" if len(resampled) > 1 and resampled.iloc[-1] > resampled.iloc[-2] else "decreasing",
    "time_series": {
        "dates": [d.strftime(time_format) for d in resampled.index],
        "counts": resampled.values.tolist()
    },
    "available_timeframes": {
        "7D": "Last 7 Days",
        "30D": "Last 30 Days", 
        "90D": "Last 3 Months (Recommended)",
        "180D": "Last 6 Months",
        "365D": "Last Year",
        "730D": "Last 2 Years"
    },
    "current_timeframe": time_window,
    "data_points": len(resampled)
}

    
    # Add severity breakdown if available
    if 'Severity' in df_filtered.columns:
        severity_total = df_filtered['Severity'].value_counts()
        response_data["severity_breakdown"] = {
            "critical": int(severity_total.get('Critical', 0)),
            "high": int(severity_total.get('High', 0)),
            "medium": int(severity_total.get('Medium', 0)),
            "low": int(severity_total.get('Low', 0))
        }
    
    return {
        "type": "image",
        "graph": timeline_image
    }